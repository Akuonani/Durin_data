---
title: "DroughtNet data cleaning"
output: html_notebook
---
load the Durin data set

```{r}
library(tidyverse)
library(readr)
library(here)
#install.packages("here")

#part 1 error identification
data <- read_csv("C:/Users/User/Desktop/Durin_data/output/DURIN_clean.csv", guess_max = Inf)
View(data)
```


filter to droughtNet
```{r}
droughtnet_data <- data %>%
  filter((ageClass == "Pioneer" | ageClass == "Mature") &
         (DroughtTrt == "Amb (0)" | DroughtTrt == "Ext (90)") &
         grepl("Field - Traits", project))
view(droughtnet_data)

```


```{r}
#plant count per site
#Count the number of plants per site
(plant_count_per_site <- droughtnet_data %>%
  group_by(siteID) %>%
  summarise(plant_count = n()))
```

```{r}
# Calculate the number of unique species per plot in each site
(species_count_per_plot_site <- droughtnet_data %>%
  group_by(siteID, DroughNet_plotID) %>%
  summarise(unique_species_count = n_distinct(species)))
view(species_count_per_plot_site)
# Calculate the total number of leaves for each species in both sites
(count_per_species <- droughtnet_data %>%
  group_by(siteID, species) %>%
  summarise(total_leaves = sum(leaf_nr, na.rm = TRUE)))
```
```{r}
#check for missing Drought treament
# Extract envelope_ID values with missing DroughtTrt
(envelopes_missing_droughttrt <- droughtnet_data %>%
  filter(is.na(DroughtTrt)) %>%
  pull(envelope_ID) %>%
  unique())
# 0 missing drought treatment

##does the treatment match with the DroughtNet_plotID( to check if the treatment is unique to a single plot
# Group by DroughNet_plotID and siteID, then count unique DroughtTrt values
treatment_uniqueness <- droughtnet_data %>%
  group_by(DroughNet_plotID, siteID) %>%
  summarise(unique_treatments = n_distinct(DroughtTrt))

# Check if any group has more than one unique treatment
(non_unique_treatments <- treatment_uniqueness %>%
  filter(unique_treatments > 1))
#found that 1.2 Tjøtta, 1.3 Tjøtta 2.2 Tjøtta, 2.1 Lgyra have more than one unique treatment

# Extract rows from the droughtnet dataset based on non-unique treatments
non_unique_treatment_rows <- droughtnet_data %>%
  semi_join(non_unique_treatments, by = c("DroughNet_plotID", "siteID")) %>%
  select(envelope_ID, species, DroughNet_plotID, DroughtTrt, siteID)

# Display the extracted rows
view(non_unique_treatment_rows)

# Filter for only Lygra's 2.1 plot from non_unique_treatment_rows
lygra_2_1_rows <- non_unique_treatment_rows %>%
    filter(siteID == "Lygra" & DroughNet_plotID == "2.1")
view(lygra_2_1_rows)
# AEG7270 has Amb(0) treatment, the rest are extreme, registered in RD4
# Filter for only Tjøtta's 2.2 plot from non_unique_treatment_rows

tjøtta_2_2_rows <- non_unique_treatment_rows %>%
    filter(siteID == "Tjøtta" & DroughNet_plotID == "2.2")
view(tjøtta_2_2_rows)
# EEN3300 has Amb(0) treatment, the rest are extreme, REGISTERED IN RD4
# Filter for only Tjøtta's 1.3 plot from non_unique_treatment_rows

tjøtta_1_3_rows <- non_unique_treatment_rows %>%
    filter(siteID == "Tjøtta" & DroughNet_plotID == "1.3")
view(tjøtta_1_3_rows)
# verify again when checking age class seems 1.3 plot is found in both pioneer and mature stages
#verified same plot number in pioneer and matur

# Filter for only Tjøtta's 1.2 plot from non_unique_treatment_rows
tjøtta_1_2_rows <- non_unique_treatment_rows %>%
    filter(siteID == "Tjøtta" & DroughNet_plotID == "1.2")
view(tjøtta_1_2_rows)
#check again later, seems 1.2 is both in pioneer and mature hence more than 1 unique treatment

#verified, same plot number in both age classes
```


```{r}
#rows missing age class in the data set
ageClass_missing <- droughtnet_data %>%
  filter(is.na(ageClass)) %>%
  select(envelope_ID, ageClass)
view(ageClass_missing)
#no envelope ids with missing ageClass
```

```{r}
#checking for exceeding envelope count per plant
# Calculate envelope counts and gather envelope IDs
# Specify the month and site for Calluna vulgaris
selected_month <- "September"  #to avoid counting calluna sampled in june
selected_site_for_calluna <- "Lygra"
envelope_details <- droughtnet_data %>%
  # Apply filter conditions for all species and add specific conditions for Calluna vulgaris
  filter(
    (species %in% c("Vaccinium myrtillus", "Empetrum nigrum", "Vaccinium vitis_idaea") & siteID %in% c("Lygra", "Tjøtta")) |
    (species == "Calluna vulgaris" & siteID == selected_site_for_calluna & month == selected_month)
  ) %>%
  group_by(species, siteID, DroughNet_plotID, plant_nr, ageClass) %>%
  group_by(species, siteID, month, DroughNet_plotID, plant_nr, ageClass) %>%
  summarise(
    envelope_count = n_distinct(envelope_ID),
    envelope_ids = list(envelope_ID),
    .groups = 'drop'
  ) %>%
  mutate(expected_count = case_when(
    species == "Vaccinium myrtillus" ~ 3,
    species %in% c("Vaccinium vitis_idaea", "Empetrum nigrum", "Calluna vulgaris") ~ 6,
    TRUE ~ NA_integer_
  ))
# Filter for cases where the envelope count exceeds the expected count, specifically for each species
incorrect_envelope_details <- envelope_details %>%
  filter((species == "Vaccinium myrtillus" & envelope_count > 3) | 
         (species == "Calluna vulgaris" & envelope_count > 6) |
         (species == "Empetrum nigrum" & envelope_count > 6) |
         (species == "Vaccinium vitis-idaea" & envelope_count > 6))
View(incorrect_envelope_details)
# Expand the envelope_ids column to display all barcodes for the incorrect cases
expanded_envelope_ids <- incorrect_envelope_details %>%
  unnest(envelope_ids)
View(expanded_envelope_ids)
# found incorrect envelope count,not registered yet in rd4 checks
#solution- to check the envelOpes    
# no exceeding envelope IDs
```


```{r}
#checking for multiple heights in Calluna vulgaris specifically Lygra
    # Filter for Calluna vulgaris, group by plant_nr and plant_height, and gather envelope_IDs
    calluna_heights_and_envelopes <- droughtnet_data %>%
      filter(species == "Calluna vulgaris", siteID == "Lygra") %>%  
      group_by(siteID, DroughNet_plotID, plant_nr, plant_height) %>%
      summarise(
        envelope_count = n(),
        envelope_ids = list(envelope_ID)
      )

    # Filter to only include rows where there's more than one height for the same plant
    multiple_heights_calluna <- calluna_heights_and_envelopes %>%
      group_by(siteID, DroughNet_plotID, plant_nr) %>%
      filter(n() > 1) %>%
      ungroup()
    view(multiple_heights_calluna)

    expanded_calluna <- multiple_heights_calluna %>% #expanded the envelope_ID collumn to display all the barcodes
      unnest(envelope_ids)
    view(expanded_calluna)
    # a good number of the plants with multiple heights-documented already in rd4 checks
# Filter for Calluna vulgaris sampled in September
calluna_heights_and_envelopes <- droughtnet_data %>%
  filter(species == "Calluna vulgaris", 
         siteID == "Lygra", 
         month == 9) %>%  
  group_by(siteID, DroughNet_plotID, plant_nr, plant_height) %>%
  summarise(
    envelope_count = n(),
    envelope_ids = list(envelope_ID),
    .groups = 'drop'  # This ensures that the resulting tibble is ungrouped
  )
view(calluna_heights_and_envelopes )
#no multiple heights in drought
#multiple heights only found when we include June
```


```{r}
#checking calluna short or long shoot type
# Get unique values of calluna_shoot_type for "Calluna vulgaris" in "Lygra"
unique_values <- droughtnet_data %>%
  filter(species == "Calluna vulgaris", siteID == "Lygra") %>%
  pull(calluna_shoot_type) %>%
  unique()
view(unique_values)
#filter calluna with missing shoot type
missing_shoot_type <- droughtnet_data %>%
  filter(species == "Calluna vulgaris", month == "September") %>%
  group_by(envelope_ID) %>%
  filter(is.na(calluna_shoot_type) | !(calluna_shoot_type %in% c("Short", "Long")))
View(missing_shoot_type %>% select(envelope_ID, calluna_shoot_type))
# 0 CV missing shoot type
```

```{r}
#check leaf age, young and old for EN and vv
#check missing leaf age in VV and EN
missing_leaf_age <- droughtnet_data %>%
  filter(species %in% c("Empetrum nigrum", "Vaccinium vitis-idaea")) %>%  # Filter for both species
  filter(is.na(leaf_age))  # Filter out rows with missing leaf age
view(missing_leaf_age %>% select(envelope_ID, species, leaf_age))
#no entries missing leaf ages
```

#part 2 solutions
```{r}

#update drought treatment
# Use mutate with case_when to update the drought_treatment for envelope_ID
droughtnet_data <- droughtnet_data %>%
  mutate(
    DroughtTrt = case_when(
      envelope_ID == "EEN3300" ~ "Ext(90)",
      envelope_ID == "AEG7270" ~ "Ext(90)",
      TRUE ~ DroughtTrt  # Keeps the existing values for all other cases
    )
  )
```

```{r}
#add "north_south" and "coastal_inland" columns to describe the experimental set-up

droughtnet_data<- droughtnet_data %>% 
  mutate(north_south = factor(siteID, levels = c("Lygra", "Sogndal", "Senja", "Tjøtta", "Kautokeino"),
                              labels = c("South", "South", "North", "North", "North"))) %>% 
  mutate(coast_inland = factor(siteID, levels = c("Lygra", "Tjøtta", "Senja", "Sogndal", "Kautokeino"),
                              labels = c("Coastal", "Coastal", "Coastal", "Inland", "Inland"))) %>%
  select(...1, envelope_ID, day, month, year, siteID, north_south, coast_inland, everything())

view(droughtnet_data)
# Filter the dataset to include only rows where 'DroughtTrt' is not missing
droughtnet_data <- droughtnet_data %>% filter(!is.na(DroughtTrt))

view(droughtnet_data)

#calculate mean thickness
# Create a subset with only the relevant columns for thickness
thickness_data <- droughtnet_data[, c("leaf_thickness_1_mm", "leaf_thickness_2_mm", "leaf_thickness_3_mm")]

# Calculate mean thickness only for rows without any NAs
mean_thickness <- rowMeans(thickness_data, na.rm = FALSE) # 'na.rm = FALSE' will return NA for rows with any NAs

# Create a new data frame with mean_thickness after leaf_thickness_3_mm
droughtnet_data <- droughtnet_data
droughtnet_data <- within(droughtnet_data, mean_thickness <- mean_thickness)

# Rearrange the columns to place mean_thickness after leaf_thickness_3_mm
col_order <- c(names(droughtnet_data)[1:which(names(droughtnet_data) == "leaf_thickness_3_mm")], 
               "mean_thickness", 
               names(droughtnet_data)[(which(names(droughtnet_data) == "leaf_thickness_3_mm") + 1):(ncol(droughtnet_data)-1)])

droughtnet_data <- droughtnet_data[, col_order]
view(droughtnet_data)

# Standardize the DroughtTrt column
droughtnet_data$DroughtTrt <- gsub("Ext\\(90\\)", "Ext (90)", droughtnet_data$DroughtTrt)
droughtnet_data$DroughtTrt <- gsub("Amb\\(0\\)", "Amb (0)", droughtnet_data$DroughtTrt)


# Initialize a list to store bounds
bounds <- list()

# Traits to calculate bounds for
traits <- c("plant_height", "mean_thickness", "SLA", "LDMC") 

# Calculate IQR, lower bound, and upper bound for each trait
for (trait in traits) {
  Q1 <- quantile(droughtnet_data[[trait]], 0.25, na.rm = TRUE)
  Q3 <- quantile(droughtnet_data[[trait]], 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1

  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  
  bounds[[trait]] <- c("Lower Bound" = lower_bound, "Upper Bound" = upper_bound)
}

# Print the bounds for each trait
bounds

# Iterate over each trait and remove outliers
# for (trait in traits) {
#     lower_bound <- bounds[[trait]]["Lower Bound"]
#     upper_bound <- bounds[[trait]]["Upper Bound"]
# 
#     # Create a logical vector for non-outlier rows
#     non_outlier_rows <- (droughtnet_data[[trait]] >= lower_bound & droughtnet_data[[trait]] <= upper_bound) | is.na(droughtnet_data[[trait]])
# 
#     # Update the dataframe to keep only non-outlier rows
#     droughtnet_data <- droughtnet_data[non_outlier_rows, ]
# }
#this code is converting the data set to NAs, havent figured out why? will come back later.......

# Write the cleaned data to a new CSV file in the current working directory
write.csv(droughtnet_data, "droughtnet_data_cleaned.csv", row.names = FALSE)


```








